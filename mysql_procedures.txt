CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `clean_lost_links`()
BEGIN
	# From players to roster
	SELECT * FROM roster WHERE player_id NOT IN (SELECT id FROM players);
	DELETE FROM roster WHERE player_id NOT IN (SELECT id FROM players);

	# From roster to mods then mod_stats
	SELECT * FROM mods WHERE roster_id NOT IN (SELECT id FROM roster);
	DELETE FROM mods WHERE roster_id NOT IN (SELECT id FROM roster);
	SELECT * FROM mod_stats WHERE mod_id NOT IN (SELECT id FROM mods);
	DELETE FROM mod_stats WHERE mod_id NOT IN (SELECT id FROM mods);

	# From roster to roster_eqpt then mod_stats
	SELECT * FROM roster_eqpt WHERE roster_id NOT IN (SELECT id FROM roster);
	DELETE FROM roster_eqpt WHERE roster_id NOT IN (SELECT id FROM roster);

	# From equipment to eqpt_stats and eqpt_missionList
	SELECT * FROM eqpt_stats WHERE equipment_id NOT IN (SELECT id FROM equipment);
	DELETE FROM eqpt_stats WHERE equipment_id NOT IN (SELECT id FROM equipment);
	SELECT * FROM eqpt_missionList WHERE equipment_id NOT IN (SELECT id FROM equipment);
	DELETE FROM eqpt_missionList WHERE equipment_id NOT IN (SELECT id FROM equipment);

	# From units to unit_tiers then unit_stats
	SELECT * FROM unit_tiers WHERE unit_id NOT IN (SELECT id FROM units);
	DELETE FROM unit_tiers WHERE unit_id NOT IN (SELECT id FROM units);
	SELECT * FROM eqpt_missionList WHERE unit_tier_id NOT IN (SELECT id FROM unit_tiers);
	DELETE FROM eqpt_missionList WHERE unit_tier_id NOT IN (SELECT id FROM unit_tiers);

END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `create_growth_tier`(
	IN p_unit_baseId VARCHAR(255), # baseId (eg: PADMEAMIDALA)
    IN growth_definition_txt MEDIUMTEXT
    )
BEGIN
	INSERT INTO debug(txt) VALUES('START create_growth_tier');
	INSERT INTO debug(txt) VALUES(CONCAT('p_unit_baseId=', p_unit_baseId));

	SELECT id INTO @p_unit_id FROM units WHERE unit_id = p_unit_baseId;
	INSERT INTO debug(txt) VALUES(CONCAT('p_unit_id=', @p_unit_id));
    
	# Clean growth_tiers and growth_stats as they will be created again
	DELETE FROM unit_growth_stats WHERE unit_growth_tier_id IN (
		SELECT unit_growth_tiers.id FROM unit_growth_tiers
		JOIN units ON units.id = unit_growth_tiers.unit_id
		WHERE units.id = @p_unit_id);
	DELETE FROM unit_growth_tiers WHERE unit_id IN (
		SELECT units.id FROM units
		WHERE units.id = @p_unit_id);

	iterator:
	LOOP
		INSERT INTO debug(txt) VALUES(CONCAT('growth_definition_txt=', growth_definition_txt));

		-- exit the loop if the list seems empty or was null;
		-- this extra caution is necessary to avoid an endless loop in the proc.
		IF CHAR_LENGTH(TRIM(growth_definition_txt)) = 0 OR growth_definition_txt IS NULL THEN
			LEAVE iterator;
		END IF;

		-- capture the next value from the list
		SET @next_growth = SUBSTRING_INDEX(growth_definition_txt,'|',1);

		-- save the length of the captured value; we will need to remove this
		-- many characters + 1 from the beginning of the string 
		-- before the next iteration
		SET @next_growth_len = CHAR_LENGTH(@next_growth);

		-- trim the value of leading and trailing spaces, in case of sloppy CSV strings
		SET @rarity = SUBSTRING_INDEX(@next_growth,',',1);
		SET @value2 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_growth,',',2),',',-1);
		SET @value3 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_growth,',',3),',',-1);
		SET @value4 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_growth,',',4),',',-1);

		-- insert the extracted value into the target table
		INSERT INTO unit_growth_tiers (unit_id, rarity) VALUES (@p_unit_id, @rarity);
        SET @tier_id = LAST_INSERT_ID();
		INSERT INTO unit_growth_stats (unit_growth_tier_id, unitStatId, unscaledDecimalValue) VALUES (@tier_id, 2, @value2);
		INSERT INTO unit_growth_stats (unit_growth_tier_id, unitStatId, unscaledDecimalValue) VALUES (@tier_id, 3, @value3);
		INSERT INTO unit_growth_stats (unit_growth_tier_id, unitStatId, unscaledDecimalValue) VALUES (@tier_id, 4, @value4);
            
		-- rewrite the original string using the `INSERT()` string function,
		-- args are original string, start position, how many characters to remove, 
		-- and what to "insert" in their place (in this case, we "insert"
		-- an empty string, which removes _nextlen + 1 characters)
		SET growth_definition_txt = INSERT(growth_definition_txt,1,@next_growth_len + 1,'');
	END LOOP;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `create_mastery_stats`(
	IN p_masteryModifierID VARCHAR(255),
    IN stat_definition_txt MEDIUMTEXT
    )
BEGIN
	#INSERT INTO debug(txt) VALUES('START create_mastery_stats');
	#INSERT INTO debug(txt) VALUES(CONCAT('p_masteryModifierID=', p_masteryModifierID));
	#INSERT INTO debug(txt) VALUES(CONCAT('stat_definition_txt=', stat_definition_txt));

	DELETE FROM unit_mastery_stats WHERE masteryModifierID = p_masteryModifierID;
	iterator:
	LOOP
		-- exit the loop if the list seems empty or was null;
		-- this extra caution is necessary to avoid an endless loop in the proc.
		IF CHAR_LENGTH(TRIM(stat_definition_txt)) = 0 OR stat_definition_txt IS NULL THEN
			LEAVE iterator;
		END IF;

		-- capture the next value from the list
		SET @next_stat = SUBSTRING_INDEX(stat_definition_txt,'|',1);

		-- save the length of the captured value; we will need to remove this
		-- many characters + 1 from the beginning of the string 
		-- before the next iteration
		SET @next_stat_len = CHAR_LENGTH(@next_stat);

		-- trim the value of leading and trailing spaces, in case of sloppy CSV strings
		SET @stat_unitStatId = SUBSTRING_INDEX(@next_stat,',',1);
		SET @stat_value = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_stat,',',2),',',-1);

		-- insert the extracted value into the target table
		INSERT INTO unit_mastery_stats (masteryModifierID) VALUES (p_masteryModifierID);
        SET @stat_id = LAST_INSERT_ID();
		UPDATE unit_mastery_stats SET
            unitStatId = @stat_unitStatId,
            value = @stat_value
            WHERE id = @stat_id;
            
		-- rewrite the original string using the `INSERT()` string function,
		-- args are original string, start position, how many characters to remove, 
		-- and what to "insert" in their place (in this case, we "insert"
		-- an empty string, which removes _nextlen + 1 characters)
		SET stat_definition_txt = INSERT(stat_definition_txt,1,@next_stat_len + 1,'');
	END LOOP;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `get_db_size`()
BEGIN
	SELECT table_schema AS "Database", 
	ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS "Size (MB)" 
	FROM information_schema.TABLES 
	GROUP BY table_schema;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `get_unit_speed`(
	IN p_allyCode INT,
    IN p_sort_by_speed BOOL
    )
BEGIN
	DROP VIEW IF EXISTS base_speed_view;
	CREATE VIEW base_speed_view AS(
	SELECT players.name AS player_name, players.allyCode AS allyCode, roster.defId AS char_name, roster.gear,
	unit_stats.statValueDecimal/10000 AS base_speed
	FROM players
	JOIN roster ON players.id = roster.player_id
	JOIN units ON units.baseId = roster.defId
	JOIN unit_tiers ON unit_tiers.unit_id = units.id AND unit_tiers.tier = roster.gear
	JOIN unit_stats ON unit_stats.unit_tier_id = unit_tiers.id
	WHERE unit_stats.unitStatId = 5
	);

	DROP VIEW IF EXISTS eqpt_speed_view;
	CREATE VIEW eqpt_speed_view AS(
	SELECT players.allyCode AS allyCode, roster.defId AS char_name,
	sum(eqpt_stats.statValueDecimal)/10000 AS eqpt_speed
	FROM players
	JOIN roster ON players.id = roster.player_id
	JOIN roster_eqpt ON roster.id = roster_eqpt.roster_id
	JOIN equipment ON roster_eqpt.equipment_id = equipment.equipment_id
	JOIN eqpt_stats ON equipment.id = eqpt_stats.equipment_id
	WHERE eqpt_stats.unitStatId = 5
	GROUP BY players.allyCode, roster.defId
	);

	DROP VIEW IF EXISTS mod_speed_view;
	CREATE VIEW mod_speed_view AS(
	SELECT players.allyCode AS allyCode, roster.defId AS char_name,
	sum(mod_stats.value) AS mod_speed
	FROM players
	JOIN roster ON players.id = roster.player_id
	JOIN mods ON roster.id = mods.roster_id
	JOIN mod_stats ON mods.id = mod_stats.mod_id
	WHERE mod_stats.unitStat = 5
	GROUP BY players.allyCode, roster.defId
	);

	DROP VIEW IF EXISTS mod_modifier_view;
	CREATE VIEW mod_modifier_view AS(
	SELECT players.allyCode AS allyCode, roster.defId AS char_name,
	count(mods.mod_set) AS mod_count,
	sum(mods.level = 15) as lvl15_count
	FROM players
	JOIN roster ON players.id = roster.player_id
	JOIN mods ON roster.id = mods.roster_id
	WHERE mods.mod_set = 4
	GROUP BY players.allyCode, roster.defId
	);

	SELECT units.nameKey AS Perso,
	case
		when IFNULL(mod_count, 0) < 4 then base_speed +IFNULL(eqpt_speed, 0)+IFNULL(mod_speed, 0)
        else case
			when IFNULL(lvl15_count, 0) < 4 then FLOOR(base_speed*1.05 +IFNULL(eqpt_speed, 0)+IFNULL(mod_speed, 0))
            else FLOOR(base_speed*1.1 +IFNULL(eqpt_speed, 0)+IFNULL(mod_speed, 0))
            end
		end as Vit
	FROM base_speed_view
	LEFT JOIN eqpt_speed_view ON eqpt_speed_view.allyCode = base_speed_view.allyCode AND eqpt_speed_view.char_name = base_speed_view.char_name
	LEFT JOIN mod_speed_view ON mod_speed_view.allyCode = base_speed_view.allyCode AND mod_speed_view.char_name = base_speed_view.char_name
	LEFT JOIN mod_modifier_view ON mod_modifier_view.allyCode = base_speed_view.allyCode AND mod_modifier_view.char_name = base_speed_view.char_name
    JOIN units ON units.unit_id = base_speed_view.char_name
	WHERE base_speed_view.allyCode = p_allyCode
    ORDER BY
		CASE WHEN p_sort_by_speed THEN Vit END DESC,
		CASE WHEN NOT p_sort_by_speed THEN nameKey END ASC;

END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `get_unit_stat`(
	IN p_allyCode INT,
    IN p_stat_name VARCHAR(255),
    IN p_sort_by_stat BOOL
    )
BEGIN
    SET @p_stat_id = 0;
    SET @p_mod_set = 0;
    SET @p_mod_count_min = 0;
	SELECT stat_id, mod_set, mod_count_min
    INTO @p_stat_id, @p_mod_set, @p_mod_count_min
    FROM statistics WHERE name_en = p_stat_name OR name_fr = p_stat_name;

	DROP VIEW IF EXISTS base_stat_view;
	CREATE VIEW base_stat_view AS(
	SELECT roster.id AS roster_id, roster.defId AS char_name,
	unit_stats.unitStatId as base_statId,
    unit_stats.statValueDecimal AS base_statValue
	FROM roster
	JOIN units ON units.baseId = roster.defId
	JOIN unit_tiers ON unit_tiers.unit_id = units.id AND unit_tiers.tier = roster.gear
	JOIN unit_stats ON unit_stats.unit_tier_id = unit_tiers.id
	);

	DROP VIEW IF EXISTS eqpt_stat_view;
	CREATE VIEW eqpt_stat_view AS(
	SELECT roster.id AS roster_id, roster.defId AS char_name,
    eqpt_stats.unitStatId AS eqpt_statId,
	sum(eqpt_stats.statValueDecimal) AS eqpt_statValue
	FROM roster
	JOIN roster_eqpt ON roster.id = roster_eqpt.roster_id
	JOIN equipment ON roster_eqpt.equipment_id = equipment.equipment_id
	JOIN eqpt_stats ON equipment.id = eqpt_stats.equipment_id
	GROUP BY roster.id, roster.defId, eqpt_stats.unitStatId
	);

	DROP VIEW IF EXISTS mod_stat_view;
	CREATE VIEW mod_stat_view AS(
	SELECT roster.id AS roster_id, roster.defId AS char_name,
	mod_stats.unitStat AS mod_statId,
	sum(mod_stats.value) AS mod_statValue
	FROM roster
	JOIN mods ON roster.id = mods.roster_id
	JOIN mod_stats ON mods.id = mod_stats.mod_id
	GROUP BY roster.id, roster.defId, mod_stats.unitStat
	);

	DROP VIEW IF EXISTS mod_modifier_view;
	CREATE VIEW mod_modifier_view AS(
	SELECT roster.id AS roster_id, roster.defId AS char_name,
	mods.mod_set,
    count(mods.mod_set) AS mod_count,
	sum(mods.level = 15) as lvl15_count
	FROM roster
	JOIN mods ON roster.id = mods.roster_id
	GROUP BY roster.id, roster.defId, mods.mod_set
	);

	SELECT units.nameKey AS Perso,
	base_statValue, eqpt_statValue, mod_statValue, mod_count, lvl15_count,
    CASE WHEN @p_mod_set = 0 THEN
		base_statValue/10000 +IFNULL(eqpt_statValue, 0)/10000+IFNULL(mod_statValue, 0)
	ELSE # @p_mod_set != 0
		CASE WHEN @p_mod_count_min = 4 THEN
			CASE WHEN IFNULL(mod_count, 0) < 4 THEN
				base_statValue/10000 +IFNULL(eqpt_statValue, 0)/10000+IFNULL(mod_statValue, 0)
			ELSE
				CASE WHEN IFNULL(lvl15_count, 0) < 4 THEN
					FLOOR(base_statValue/10000*1.05 +IFNULL(eqpt_statValue, 0)/10000+IFNULL(mod_statValue, 0))
				ELSE
					FLOOR(base_statValue/10000*1.1 +IFNULL(eqpt_statValue, 0)/10000+IFNULL(mod_statValue, 0))
				END
			END
		END
	END AS stat_value
	FROM roster
	LEFT JOIN base_stat_view ON base_stat_view.roster_id = roster.id AND base_stat_view.base_statId = @p_stat_id
	LEFT JOIN eqpt_stat_view ON eqpt_stat_view.roster_id = roster.id AND eqpt_stat_view.eqpt_statId = @p_stat_id
	LEFT JOIN mod_stat_view ON mod_stat_view.roster_id = roster.id AND mod_stat_view.mod_statId = @p_stat_id
	LEFT JOIN mod_modifier_view ON mod_modifier_view.roster_id = roster.id AND mod_modifier_view.mod_set = @p_mod_set
    JOIN units ON units.unit_id = base_stat_view.char_name
    JOIN players ON players.id = roster.player_id
	WHERE players.allyCode = p_allyCode
    ORDER BY
		CASE WHEN p_sort_by_stat THEN stat_value END DESC,
		CASE WHEN NOT p_sort_by_stat THEN units.nameKey END ASC;

END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `refresh_tables`()
BEGIN
	# TABLE debug
    IF EXISTS(SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'debug') THEN
        DROP TABLE debug;
	END IF;
    CREATE TABLE debug
    (
		txt MEDIUMTEXT
	);
    
	# TABLE players
    IF EXISTS(SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'players') THEN
        DROP TABLE players;
	END IF;
    CREATE TABLE players
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        allyCode INT,
        guildName VARCHAR(255),
        player_id VARCHAR(30),
        lastActivity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        level INT,
        name VARCHAR(255),
        poUTCOffsetMinutes INT,
        lastUpdated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
	);
    
	# TABLE roster
    IF EXISTS(SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'roster') THEN
        DROP TABLE roster;
	END IF;
    CREATE TABLE roster
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        player_id INT,
        combatType INT,
        defId VARCHAR(255),
        gear INT,
        gp INT,
        level INT,
        nameKey VARCHAR(255),
        rarity INT,
        relic_currentTier INT
	);
        
	# TABLE mods
	DROP TABLE IF EXISTS mods;
    CREATE TABLE mods
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        roster_id INT,
        level INT,
        pips INT,
        mod_set INT,
        slot INT,
        tier INT
	);
    
	# TABLE mod_stats
	DROP TABLE IF EXISTS mod_stats;
    CREATE TABLE mod_stats
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        mod_id INT,
        type VARCHAR(10), # 'primary' or 'secondary'
        unitStat INT,
        value FLOAT
	);
    
	# TABLE roster_eqpt
    DROP TABLE IF EXISTS roster_eqpt;
    CREATE TABLE roster_eqpt
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        roster_id INT,
        equipment_id VARCHAR(255)
	);
    
	# TABLE units
    DROP TABLE IF EXISTS units;
    CREATE TABLE units
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        baseId VARCHAR(255),
        combatType INT,
        descKey TEXT,
        forceAlignment INT,
        unit_id VARCHAR(255),
        nameKey VARCHAR(255),
        primaryStat INT,
        masteryModifierID VARCHAR(255)
	);

	# TABLE unit_tiers
    DROP TABLE IF EXISTS unit_tiers;
    CREATE TABLE unit_tiers
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        unit_id INT,
        equipmentSet1 VARCHAR(255),
        equipmentSet2 VARCHAR(255),
        equipmentSet3 VARCHAR(255),
        equipmentSet4 VARCHAR(255),
        equipmentSet5 VARCHAR(255),
        equipmentSet6 VARCHAR(255),
        tier INT
	);
    
	# TABLE unit_stats
    DROP TABLE IF EXISTS unit_stats;
    CREATE TABLE unit_stats
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        unit_tier_id INT,
        scalar INT,
        statValueDecimal INT,
        uiDisplayOverrideValue INT,
        unitStatId INT,
        unscaledDecimalValue BIGINT
	);
    
	# TABLE unit_growth_tiers
    DROP TABLE IF EXISTS unit_growth_tiers;
    CREATE TABLE unit_growth_tiers
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        unit_id INT,
        rarity INT
	);
    
	# TABLE unit_growth_stats
    DROP TABLE IF EXISTS unit_growth_stats;
    CREATE TABLE unit_growth_stats
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        unit_growth_tier_id INT,
        unitStatId INT,
        unscaledDecimalValue BIGINT
	);
    
	# TABLE unit_mastery_stats
    DROP TABLE IF EXISTS unit_mastery_stats;
    CREATE TABLE unit_mastery_stats
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        masteryModifierID VARCHAR(255),
        unitStatId INT,
        value FLOAT
	);

	# TABLE guild_teams
	DROP TABLE IF EXISTS guild_teams;
	CREATE TABLE guild_teams
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        name VARCHAR(255)
	);

	# TABLE guild_subteams
	DROP TABLE IF EXISTS guild_subteams;
	CREATE TABLE guild_subteams
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        team_id VARCHAR(255),
        name VARCHAR(255),
        minimum INT
	);
    
	# TABLE guild_team_roster
	DROP TABLE IF EXISTS guild_team_roster;
	CREATE TABLE guild_team_roster
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        subteam_id VARCHAR(255),
        unit_id VARCHAR(255),
        rarity_min INT,
        gear_min VARCHAR(2),
        rarity_reco INT,
        gear_reco VARCHAR(2)
	);
    
	# TABLE equipment
	DROP TABLE IF EXISTS equipment;
	CREATE TABLE equipment
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        equipment_id VARCHAR(255),
        mark VARCHAR(255),
        nameKey VARCHAR(255),
        recipeId VARCHAR(255),
        requiredLevel INT,
        requiredRarity INT,
        sellValue_bonusQuantity INT,
        sellValue_currency INT,
        sellValue_quantity INT,
        tier INT,
        type INT
	);
    
	# TABLE eqpt_stats
    DROP TABLE IF EXISTS eqpt_stats;
    CREATE TABLE eqpt_stats
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        equipment_id INT,
        scalar INT,
        statValueDecimal INT,
        uiDisplayOverrideValue INT,
        unitStatId INT,
        unscaledDecimalValue BIGINT
	);
    
	# TABLE eqpt_lookupMissionList
    DROP TABLE IF EXISTS eqpt_missionList;
    CREATE TABLE eqpt_lookupMissionList
    (
		id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        equipment_id INT,
        missionType VARCHAR(255), # 'mission' or 'raid'
        event BOOL,
        campaignId VARCHAR(255),
        campaignMapId VARCHAR(255),
        campaignMissionId VARCHAR(255),
        campaignNodeDifficulty INT,
        campaignNodeId VARCHAR(255)
	);
    
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_eqpt_missionList`(
	IN p_equipment_id INT,
    IN p_missionType VARCHAR(255),
    IN mission_definition_txt MEDIUMTEXT
    )
BEGIN
	#INSERT INTO debug(txt) VALUES('START update_eqpt_missions');
	#INSERT INTO debug(txt) VALUES(CONCAT('p_equipment_id=', p_equipment_id));
	#INSERT INTO debug(txt) VALUES(CONCAT('p_missionType=', p_missionType));
	#INSERT INTO debug(txt) VALUES(CONCAT('mission_definition_txt=', mission_definition_txt));

	DELETE FROM eqpt_missionList WHERE equipment_id = p_equipment_id AND missionType = p_missionType;
	iterator:
	LOOP
		-- exit the loop if the list seems empty or was null;
		-- this extra caution is necessary to avoid an endless loop in the proc.
		IF CHAR_LENGTH(TRIM(mission_definition_txt)) = 0 OR mission_definition_txt IS NULL THEN
			LEAVE iterator;
		END IF;

		-- capture the next value from the list
		SET @next_mission = SUBSTRING_INDEX(mission_definition_txt,'|',1);

		-- save the length of the captured value; we will need to remove this
		-- many characters + 1 from the beginning of the string 
		-- before the next iteration
		SET @next_mission_len = CHAR_LENGTH(@next_mission);

		-- trim the value of leading and trailing spaces, in case of sloppy CSV strings
		SET @event = SUBSTRING_INDEX(@next_mission,',',1);
		SET @campaignId = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mission,',',2),',',-1);
		SET @campaignMapId = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mission,',',3),',',-1);
		SET @campaignMissionId = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mission,',',4),',',-1);
		SET @campaignNodeDifficulty = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mission,',',5),',',-1);
		SET @campaignNodeId = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mission,',',6),',',-1);

		-- insert the extracted value into the target table
		INSERT INTO eqpt_missionList (equipment_id,missionType) VALUES (p_equipment_id,p_missionType);
        SET @mission_id = LAST_INSERT_ID();
		UPDATE eqpt_missionList SET
			event = @event,
            campaignId = @campaignId,
            campaignMapId = @campaignMapId,
            campaignMissionId = @campaignMissionId,
            campaignNodeDifficulty = @campaignNodeDifficulty,
            campaignNodeId = @campaignNodeId
            WHERE id = @mission_id;
            
		-- rewrite the original string using the `INSERT()` string function,
		-- args are original string, start position, how many characters to remove, 
		-- and what to "insert" in their place (in this case, we "insert"
		-- an empty string, which removes _nextlen + 1 characters)
		SET mission_definition_txt = INSERT(mission_definition_txt,1,@next_mission_len + 1,'');
	END LOOP;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_eqpt_stats`(
	IN p_equipment_id INT,
    IN stat_definition_txt MEDIUMTEXT
    )
BEGIN
	#INSERT INTO debug(txt) VALUES('START update_eqpt_stats');
	#INSERT INTO debug(txt) VALUES(CONCAT('p_equipment_id=', p_equipment_id));
	#INSERT INTO debug(txt) VALUES(CONCAT('stat_definition_txt=', stat_definition_txt));

	DELETE FROM eqpt_stats WHERE equipment_id = p_equipment_id;
	iterator:
	LOOP
		-- exit the loop if the list seems empty or was null;
		-- this extra caution is necessary to avoid an endless loop in the proc.
		IF CHAR_LENGTH(TRIM(stat_definition_txt)) = 0 OR stat_definition_txt IS NULL THEN
			LEAVE iterator;
		END IF;

		-- capture the next value from the list
		SET @next_stat = SUBSTRING_INDEX(stat_definition_txt,'|',1);

		-- save the length of the captured value; we will need to remove this
		-- many characters + 1 from the beginning of the string 
		-- before the next iteration
		SET @next_stat_len = CHAR_LENGTH(@next_stat);

		-- trim the value of leading and trailing spaces, in case of sloppy CSV strings
		SET @stat_scalar = SUBSTRING_INDEX(@next_stat,',',1);
		SET @stat_statValueDecimal = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_stat,',',2),',',-1);
		SET @stat_uiDisplayOverrideValue = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_stat,',',3),',',-1);
		SET @stat_unitStatId = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_stat,',',4),',',-1);
		SET @stat_unscaledDecimalValue = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_stat,',',5),',',-1);

		-- insert the extracted value into the target table
		INSERT INTO eqpt_stats (equipment_id) VALUES (p_equipment_id);
        SET @stat_id = LAST_INSERT_ID();
		UPDATE eqpt_stats SET
			scalar = @stat_scalar,
            statValueDecimal = @stat_statValueDecimal,
            uiDisplayOverrideValue = @stat_uiDisplayOverrideValue,
            unitStatId = @stat_unitStatId,
            unscaledDecimalValue = @stat_unscaledDecimalValue
            WHERE id = @stat_id;
            
		-- rewrite the original string using the `INSERT()` string function,
		-- args are original string, start position, how many characters to remove, 
		-- and what to "insert" in their place (in this case, we "insert"
		-- an empty string, which removes _nextlen + 1 characters)
		SET stat_definition_txt = INSERT(stat_definition_txt,1,@next_stat_len + 1,'');
	END LOOP;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_equipment`(
	e_equipment_id VARCHAR(255),
	e_mark VARCHAR(255),
	e_nameKey VARCHAR(255),
	e_recipeId VARCHAR(255),
	e_requiredLevel INT,
	e_requiredRarity INT,
	e_sellValue_bonusQuantity INT,
	e_sellValue_currency INT,
	e_sellValue_quantity INT,
	e_tier INT,
	e_type INT,
	stat_lookup_raid_definition_txt MEDIUMTEXT
    )
BEGIN
	#INSERT INTO debug(txt) VALUES('START update_equipment');
	#INSERT INTO debug(txt) VALUES(CONCAT('e_equipment_id=', e_equipment_id));

	IF NOT EXISTS (SELECT * FROM equipment WHERE equipment_id = e_equipment_id) THEN
		INSERT INTO equipment(equipment_id) VALUES(e_equipment_id);
    END IF;
    UPDATE equipment SET
		equipment_id = e_equipment_id,
		mark = e_mark,
		nameKey = e_nameKey,
		recipeId = e_recipeId,
		requiredLevel = e_requiredLevel,
		requiredRarity = e_requiredRarity,
		sellValue_bonusQuantity = e_sellValue_bonusQuantity,
		sellValue_currency = e_sellValue_currency,
		sellValue_quantity = e_sellValue_quantity,
		tier = e_tier,
		type = e_type
        WHERE equipment_id = e_equipment_id;
	
    SET @p_current_id = (SELECT id FROM equipment WHERE equipment_id = e_equipment_id);
	SET @stat_definition_txt = SUBSTRING_INDEX(stat_lookup_raid_definition_txt,'/',1);
	SET @lookup_definition_txt = SUBSTRING_INDEX(SUBSTRING_INDEX(stat_lookup_raid_definition_txt,'/',2),'/',-1);
	SET @raid_definition_txt = SUBSTRING_INDEX(stat_lookup_raid_definition_txt,'/',-1);

    CALL update_eqpt_stats(@p_current_id, @stat_definition_txt);
    CALL update_eqpt_missionList(@p_current_id, 'mission', @lookup_definition_txt);
    CALL update_eqpt_missionList(@p_current_id, 'raid', @raid_definition_txt);
    
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_mastery`(
    IN mastery_definition_txt MEDIUMTEXT
    )
BEGIN
	INSERT INTO debug(txt) VALUES('START update_mastery');
	INSERT INTO debug(txt) VALUES(CONCAT('mastery_definition_txt=', mastery_definition_txt));
    
	iterator:
	LOOP
		-- exit the loop if the list seems empty or was null;
		-- this extra caution is necessary to avoid an endless loop in the proc.
		IF CHAR_LENGTH(TRIM(mastery_definition_txt)) = 0 OR mastery_definition_txt IS NULL THEN
			LEAVE iterator;
		END IF;

		-- capture the next value from the list
		SET @next_mastery = SUBSTRING_INDEX(mastery_definition_txt,'/',1);
		#INSERT INTO debug(txt) VALUES(CONCAT('LOOP update_tiers @next_mastery=', @next_mastery));

		-- save the length of the captured value; we will need to remove this
		-- many characters + 1 from the beginning of the string 
		-- before the next iteration
		SET @next_mastery_len = CHAR_LENGTH(@next_mastery);

		-- trim the value of leading and trailing spaces, in case of sloppy CSV strings
		SET @p_masteryModifierID = SUBSTRING_INDEX(@next_mastery,',',1);

		SET @before_stat_definition = SUBSTRING_INDEX(@next_mastery,',',1);
		SET @pos_stat_definition = CHAR_LENGTH(@before_stat_definition);
		SET @stat_definition_txt = INSERT(@next_mastery,1,@pos_stat_definition + 1,'');
        
		CALL create_mastery_stats(
			@p_masteryModifierID,
			@stat_definition_txt);
            
		-- rewrite the original string using the `INSERT()` string function,
		-- args are original string, start position, how many characters to remove, 
		-- and what to "insert" in their place (in this case, we "insert"
		-- an empty string, which removes _nextlen + 1 characters)
		SET mastery_definition_txt = INSERT(mastery_definition_txt,1,@next_mastery_len + 1,'');
	END LOOP;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_mods`(
	IN p_roster_id INT,
    IN mod_definition_txt MEDIUMTEXT
    )
BEGIN
	#INSERT INTO debug(txt) VALUES('START update_mods');
	#INSERT INTO debug(txt) VALUES(CONCAT('p_roster_id=', p_roster_id));
	#INSERT INTO debug(txt) VALUES(CONCAT('mod_definition_txt=', mod_definition_txt));

	#DELETE FROM mod_stats WHERE mod_id IN(SELECT id FROM mods WHERE roster_id = p_roster_id);
	#DELETE FROM mods WHERE roster_id = p_roster_id;
	iterator:
	LOOP
		-- exit the loop if the list seems empty or was null;
		-- this extra caution is necessary to avoid an endless loop in the proc.
		IF CHAR_LENGTH(TRIM(mod_definition_txt)) = 0 OR mod_definition_txt IS NULL THEN
			LEAVE iterator;
		END IF;

		-- capture the next value from the list
		SET @next_mod = SUBSTRING_INDEX(mod_definition_txt,'|',1);
		#INSERT INTO debug(txt) VALUES(CONCAT('LOOP update_mods @next_mod=', @next_mod));

		-- save the length of the captured value; we will need to remove this
		-- many characters + 1 from the beginning of the string 
		-- before the next iteration
		SET @next_mod_len = CHAR_LENGTH(@next_mod);

		-- trim the value of leading and trailing spaces, in case of sloppy CSV strings
		SET @mod_level = SUBSTRING_INDEX(@next_mod,',',1);
		SET @mod_pips = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',2),',',-1);
		SET @mod_primaryStat_unitStat = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',3),',',-1);
		SET @mod_primaryStat_value = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',4),',',-1);
		SET @mod_secondaryStat1_unitStat = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',5),',',-1);
		SET @mod_secondaryStat1_value = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',6),',',-1);
		SET @mod_secondaryStat2_unitStat = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',7),',',-1);
		SET @mod_secondaryStat2_value = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',8),',',-1);
		SET @mod_secondaryStat3_unitStat = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',9),',',-1);
		SET @mod_secondaryStat3_value = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',10),',',-1);
		SET @mod_secondaryStat4_unitStat = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',11),',',-1);
		SET @mod_secondaryStat4_value = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',12),',',-1);
		SET @mod_set = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',13),',',-1);
		SET @mod_slot = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',14),',',-1);
		SET @mod_tier = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_mod,',',15),',',-1);

		-- insert the extracted value into the target table
		INSERT INTO mods (roster_id) VALUES (p_roster_id);
        SET @mod_id = LAST_INSERT_ID();
		UPDATE mods SET
			level = @mod_level,
            pips = @mod_pips,
            mod_set = @mod_set,
            slot = @mod_slot,
            tier = @mod_tier
            WHERE id = @mod_id;
            
		# Refresh equipment list
		IF NOT (@mod_primaryStat_unitStat = 0) THEN
			INSERT INTO mod_stats(mod_id,type,unitStat,value) VALUES(@mod_id,'primary',@mod_primaryStat_unitStat,@mod_primaryStat_value);
		END IF;
		IF NOT (@mod_secondaryStat1_unitStat = 0) THEN
			INSERT INTO mod_stats(mod_id,type,unitStat,value) VALUES(@mod_id,'secondary',@mod_secondaryStat1_unitStat,@mod_secondaryStat1_value);
		END IF;
		IF NOT (@mod_secondaryStat2_unitStat = 0) THEN
			INSERT INTO mod_stats(mod_id,type,unitStat,value) VALUES(@mod_id,'secondary',@mod_secondaryStat2_unitStat,@mod_secondaryStat2_value);
		END IF;
		IF NOT (@mod_secondaryStat3_unitStat = 0) THEN
			INSERT INTO mod_stats(mod_id,type,unitStat,value) VALUES(@mod_id,'secondary',@mod_secondaryStat3_unitStat,@mod_secondaryStat3_value);
		END IF;
		IF NOT (@mod_secondaryStat4_unitStat = 0) THEN
			INSERT INTO mod_stats(mod_id,type,unitStat,value) VALUES(@mod_id,'secondary',@mod_secondaryStat4_unitStat,@mod_secondaryStat4_value);
		END IF;
            
		-- rewrite the original string using the `INSERT()` string function,
		-- args are original string, start position, how many characters to remove, 
		-- and what to "insert" in their place (in this case, we "insert"
		-- an empty string, which removes _nextlen + 1 characters)
		SET mod_definition_txt = INSERT(mod_definition_txt,1,@next_mod_len + 1,'');
	END LOOP;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_player`(
	IN p_allyCode INT,
    IN p_guildName VARCHAR(255),
    IN p_player_id VARCHAR(30),
    IN p_lastActivity DATETIME,
    IN p_level int,
    IN p_name VARCHAR(255),
    IN p_poUTCOffsetMinutes INT,
    IN roster_definition_txt MEDIUMTEXT
    )
BEGIN
	#INSERT INTO debug(txt) VALUES('START update_player');
	#INSERT INTO debug(txt) VALUES(CONCAT('p_allyCode=', p_allyCode));
	#INSERT INTO debug(txt) VALUES(CONCAT('p_name=', p_name));
	#INSERT INTO debug(txt) VALUES(CONCAT('p_level=', p_level));

	IF NOT EXISTS (SELECT * FROM players WHERE allyCode = p_allyCode) THEN
		INSERT INTO players(allyCode) VALUES(p_allyCode);
    END IF;
	IF p_allyCode IN (SELECT allyCode FROM players where (CURRENT_TIMESTAMP-lastUpdated)> 3600)
    THEN
		UPDATE players SET
			guildName = p_guildName,
			player_id = p_player_id,
			lastActivity = p_lastActivity,
			level = p_level,
			name = p_name,
			poUTCOffsetMinutes = p_poUTCOffsetMinutes,
			lastUpdated = CURRENT_TIMESTAMP
			WHERE allyCode = p_allyCode;
		
		SET @p_player_id = (SELECT id FROM players WHERE allyCode = p_allyCode);
		CALL update_roster(@p_player_id, roster_definition_txt);
	END IF;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_roster`(
	IN p_player_id INT,
    IN roster_definition_txt MEDIUMTEXT
    )
BEGIN
	#INSERT INTO debug(txt) VALUES('START update_roster');
	#INSERT INTO debug(txt) VALUES(CONCAT('p_player_id=', p_player_id));
	#INSERT INTO debug(txt) VALUES(CONCAT('roster_definition_txt=', roster_definition_txt));

	# Clean mods and equipment as they will be created again
	DELETE FROM mod_stats WHERE mod_id IN (
		SELECT mods.id FROM mods
		JOIN roster ON roster.id = mods.roster_id
		WHERE roster.player_id = p_player_id);
	DELETE FROM mods WHERE roster_id IN (
		SELECT roster.id FROM roster
		WHERE roster.player_id = p_player_id);
	DELETE FROM roster_eqpt WHERE roster_id IN (
		SELECT roster.id FROM roster
		WHERE roster.player_id = p_player_id);

	iterator:
	LOOP
		-- exit the loop if the list seems empty or was null;
		-- this extra caution is necessary to avoid an endless loop in the proc.
		IF CHAR_LENGTH(TRIM(roster_definition_txt)) = 0 OR roster_definition_txt IS NULL THEN
			LEAVE iterator;
		END IF;

		-- capture the next value from the list
		SET @next_roster = SUBSTRING_INDEX(roster_definition_txt,'/',1);
		#INSERT INTO debug(txt) VALUES(CONCAT('LOOP update_roster @next_roster=', @next_roster));

		-- save the length of the captured value; we will need to remove this
		-- many characters + 1 from the beginning of the string 
		-- before the next iteration
		SET @next_roster_len = CHAR_LENGTH(@next_roster);

		-- trim the value of leading and trailing spaces, in case of sloppy CSV strings
		SET @p_combatType = SUBSTRING_INDEX(@next_roster,',',1);
		SET @p_defId = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',2),',',-1);
		SET @p_gear = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',3),',',-1);
		SET @p_gp = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',4),',',-1);
		SET @p_level = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',5),',',-1);
		SET @p_nameKey = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',6),',',-1);
		SET @p_rarity = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',7),',',-1);
		SET @p_relic_currentTier = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',8),',',-1);
		SET @p_equipped1 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',9),',',-1);
		SET @p_equipped2 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',10),',',-1);
		SET @p_equipped3 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',11),',',-1);
		SET @p_equipped4 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',12),',',-1);
		SET @p_equipped5 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',13),',',-1);
		SET @p_equipped6 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_roster,',',14),',',-1);

		SET @before_mod_definition = SUBSTRING_INDEX(@next_roster,',',14);
		SET @pos_mod_definition = CHAR_LENGTH(@before_mod_definition);
		SET @mod_definition_txt = INSERT(@next_roster,1,@pos_mod_definition + 1,'');

		CALL update_roster_element(
			p_player_id,
			@p_combatType,
			@p_defId,
			@p_gear,
			@p_gp,
			@p_level,
			@p_nameKey,
			@p_rarity,
			@p_relic_currentTier,
			@p_equipped1,
			@p_equipped2,
			@p_equipped3,
			@p_equipped4,
			@p_equipped5,
			@p_equipped6,
			@mod_definition_txt);
            
		-- rewrite the original string using the `INSERT()` string function,
		-- args are original string, start position, how many characters to remove, 
		-- and what to "insert" in their place (in this case, we "insert"
		-- an empty string, which removes _nextlen + 1 characters)
		SET roster_definition_txt = INSERT(roster_definition_txt,1,@next_roster_len + 1,'');
	END LOOP;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_roster_element`(
	IN p_player_id INT,
	IN p_combatType INT,
    IN p_defId VARCHAR(255),
    IN p_gear INT,
    IN p_gp INT,
    IN p_level INT,
    IN p_nameKey VARCHAR(255),
    IN p_rarity INT,
    IN p_relic_currentTier INT,
    IN p_equipped1 VARCHAR(255),
    IN p_equipped2 VARCHAR(255),
    IN p_equipped3 VARCHAR(255),
    IN p_equipped4 VARCHAR(255),
    IN p_equipped5 VARCHAR(255),
    IN p_equipped6 VARCHAR(255),
    IN mod_definition_txt MEDIUMTEXT
    )
BEGIN
    #INSERT INTO debug(txt) VALUES('START update_roster_element');
    #INSERT INTO debug(txt) VALUES(CONCAT('p_player_id=', p_player_id));
    #INSERT INTO debug(txt) VALUES(CONCAT('p_defId=', p_defId));
    #INSERT INTO debug(txt) VALUES(CONCAT('mod_definition_txt=', mod_definition_txt));

	IF NOT EXISTS (SELECT * FROM roster WHERE player_id = p_player_id AND defId = p_defId) THEN
		INSERT INTO roster(player_id,defId) VALUES(p_player_id,p_defId);
    END IF;
    UPDATE roster SET
		combatType = p_combatType,
        gear = p_gear,
        gp = p_gp,
        level = p_level,
        nameKey = p_nameKey,
        rarity = p_rarity,
        relic_currentTier = p_relic_currentTier
        WHERE player_id = p_player_id AND defId = p_defId;

	SET @roster_id = (SELECT id FROM roster WHERE player_id = p_player_id AND defId = p_defId);
    CALL update_mods(@roster_id, mod_definition_txt);
    
    # Refresh equipment list
    #DELETE FROM roster_eqpt WHERE roster_id = @roster_id;
	IF NOT (p_equipped1 = '') THEN
		INSERT INTO roster_eqpt(roster_id,equipment_id) VALUES(@roster_id,p_equipped1);
    END IF;
	IF NOT (p_equipped2 = '') THEN
		INSERT INTO roster_eqpt(roster_id,equipment_id) VALUES(@roster_id,p_equipped2);
    END IF;
	IF NOT (p_equipped3 = '') THEN
		INSERT INTO roster_eqpt(roster_id,equipment_id) VALUES(@roster_id,p_equipped3);
    END IF;
	IF NOT (p_equipped4 = '') THEN
		INSERT INTO roster_eqpt(roster_id,equipment_id) VALUES(@roster_id,p_equipped4);
    END IF;
	IF NOT (p_equipped5 = '') THEN
		INSERT INTO roster_eqpt(roster_id,equipment_id) VALUES(@roster_id,p_equipped5);
    END IF;
	IF NOT (p_equipped6 = '') THEN
		INSERT INTO roster_eqpt(roster_id,equipment_id) VALUES(@roster_id,p_equipped6);
    END IF;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_tiers`(
	IN p_unit_id INT,
    IN tier_definition_txt MEDIUMTEXT
    )
BEGIN
	#INSERT INTO debug(txt) VALUES('START update_tiers');
	#INSERT INTO debug(txt) VALUES(CONCAT('p_unit_id=', p_unit_id));
	#INSERT INTO debug(txt) VALUES(CONCAT('tier_definition_txt=', tier_definition_txt));
    
	iterator:
	LOOP
		-- exit the loop if the list seems empty or was null;
		-- this extra caution is necessary to avoid an endless loop in the proc.
		IF CHAR_LENGTH(TRIM(tier_definition_txt)) = 0 OR tier_definition_txt IS NULL THEN
			LEAVE iterator;
		END IF;

		-- capture the next value from the list
		SET @next_tiers = SUBSTRING_INDEX(tier_definition_txt,'/',1);
		#INSERT INTO debug(txt) VALUES(CONCAT('LOOP update_tiers @next_tiers=', @next_tiers));

		-- save the length of the captured value; we will need to remove this
		-- many characters + 1 from the beginning of the string 
		-- before the next iteration
		SET @next_tiers_len = CHAR_LENGTH(@next_tiers);

		-- trim the value of leading and trailing spaces, in case of sloppy CSV strings
		SET @p_equipmentSet1 = SUBSTRING_INDEX(@next_tiers,',',1);
		SET @p_equipmentSet2 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_tiers,',',2),',',-1);
		SET @p_equipmentSet3 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_tiers,',',3),',',-1);
		SET @p_equipmentSet4 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_tiers,',',4),',',-1);
		SET @p_equipmentSet5 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_tiers,',',5),',',-1);
		SET @p_equipmentSet6 = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_tiers,',',6),',',-1);
		SET @p_tier = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_tiers,',',7),',',-1);

		SET @before_stat_definition = SUBSTRING_INDEX(@next_tiers,',',7);
		SET @pos_stat_definition = CHAR_LENGTH(@before_stat_definition);
		SET @stat_definition_txt = INSERT(@next_tiers,1,@pos_stat_definition + 1,'');

		CALL update_tier_element(
			p_unit_id,
			@p_equipmentSet1,
			@p_equipmentSet2,
			@p_equipmentSet3,
			@p_equipmentSet4,
			@p_equipmentSet5,
			@p_equipmentSet6,
			@p_tier,
			@stat_definition_txt);
            
		-- rewrite the original string using the `INSERT()` string function,
		-- args are original string, start position, how many characters to remove, 
		-- and what to "insert" in their place (in this case, we "insert"
		-- an empty string, which removes _nextlen + 1 characters)
		SET tier_definition_txt = INSERT(tier_definition_txt,1,@next_tiers_len + 1,'');
	END LOOP;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_tier_element`(
	IN p_unit_id INT,
	IN p_equipmentSet1 VARCHAR(255),
	IN p_equipmentSet2 VARCHAR(255),
	IN p_equipmentSet3 VARCHAR(255),
	IN p_equipmentSet4 VARCHAR(255),
	IN p_equipmentSet5 VARCHAR(255),
	IN p_equipmentSet6 VARCHAR(255),
	IN p_tier INT,
    IN stat_definition_txt MEDIUMTEXT
    )
BEGIN
    #INSERT INTO debug(txt) VALUES('START update_tier_element');
    #INSERT INTO debug(txt) VALUES(CONCAT('p_unit_id=', p_unit_id));
    #INSERT INTO debug(txt) VALUES(CONCAT('p_tier=', p_tier));
    #INSERT INTO debug(txt) VALUES(CONCAT('stat_definition_txt=', stat_definition_txt));

	IF NOT EXISTS (SELECT * FROM unit_tiers WHERE unit_id = p_unit_id AND tier = p_tier) THEN
		INSERT INTO unit_tiers(unit_id,tier) VALUES(p_unit_id,p_tier);
    END IF;
    UPDATE unit_tiers SET
		equipmentSet1 = p_equipmentSet1,
		equipmentSet2 = p_equipmentSet2,
		equipmentSet3 = p_equipmentSet3,
		equipmentSet4 = p_equipmentSet4,
		equipmentSet5 = p_equipmentSet5,
		equipmentSet6 = p_equipmentSet6
        WHERE unit_id = p_unit_id AND tier = p_tier;

	SET @unit_tier_id = (SELECT id FROM unit_tiers WHERE unit_id = p_unit_id AND tier = p_tier);
    CALL update_unit_stats(@unit_tier_id, stat_definition_txt);
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_unit`(
	p_baseId VARCHAR(255),
	p_combatType INT,
	p_descKey TEXT,
	p_forceAlignment INT,
	p_unit_id VARCHAR(255),
	p_nameKey VARCHAR(255),
    tier_definition_txt MEDIUMTEXT
    )
BEGIN
	#INSERT INTO debug(txt) VALUES('START update_unit');
	#INSERT INTO debug(txt) VALUES(CONCAT('p_unit_id=', p_unit_id));

	IF NOT EXISTS (SELECT * FROM units WHERE unit_id = p_unit_id) THEN
		INSERT INTO units(unit_id) VALUES(p_unit_id);
    END IF;
    UPDATE units SET
		baseId = p_baseId,
		combatType = p_combatType,
		descKey = p_descKey,
		forceAlignment = p_forceAlignment,
		unit_id = p_unit_id,
		nameKey = p_nameKey
        WHERE unit_id = p_unit_id;
	
    SET @p_current_id = (SELECT id FROM units WHERE unit_id = p_unit_id);
    CALL update_tiers(@p_current_id, tier_definition_txt);
    
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_units_gameData`(
    IN units_definition_txt MEDIUMTEXT
    )
BEGIN
	INSERT INTO debug(txt) VALUES('START update_units_gameData');
    
	iterator:
	LOOP
		INSERT INTO debug(txt) VALUES(CONCAT('units_definition_txt=', units_definition_txt));
        
		-- exit the loop if the list seems empty or was null;
		-- this extra caution is necessary to avoid an endless loop in the proc.
		IF CHAR_LENGTH(TRIM(units_definition_txt)) = 0 OR units_definition_txt IS NULL THEN
			LEAVE iterator;
		END IF;

		-- capture the next value from the list
		SET @next_unit = SUBSTRING_INDEX(units_definition_txt,'/',1);
		#INSERT INTO debug(txt) VALUES(CONCAT('LOOP update_tiers @next_unit=', @next_unit));

		-- save the length of the captured value; we will need to remove this
		-- many characters + 1 from the beginning of the string 
		-- before the next iteration
		SET @next_unit_len = CHAR_LENGTH(@next_unit);

		-- trim the value of leading and trailing spaces, in case of sloppy CSV strings
		SET @p_unit_it = SUBSTRING_INDEX(@next_unit,',',1);
		SET @p_primaryStat = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_unit,',',2),',',-1);
		SET @p_masteryModifierID = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_unit,',',3),',',-1);

		SET @before_growth_definition = SUBSTRING_INDEX(@next_unit,',',3);
		SET @pos_growth_definition = CHAR_LENGTH(@before_growth_definition);
		SET @growth_definition_txt = INSERT(@next_unit,1,@pos_growth_definition + 1,'');
        
		UPDATE units SET
			primaryStat = @p_primaryStat,
            masteryModifierID = @p_masteryModifierID
            WHERE unit_id = @p_unit_it;
        
		CALL create_growth_tier(
			@p_unit_it,
			@growth_definition_txt);
            
		-- rewrite the original string using the `INSERT()` string function,
		-- args are original string, start position, how many characters to remove, 
		-- and what to "insert" in their place (in this case, we "insert"
		-- an empty string, which removes _nextlen + 1 characters)
		SET units_definition_txt = INSERT(units_definition_txt,1,@next_unit_len + 1,'');
	END LOOP;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `update_unit_stats`(
	IN p_unit_tier_id INT,
    IN stat_definition_txt MEDIUMTEXT
    )
BEGIN
	#INSERT INTO debug(txt) VALUES('START update_unit_stats');
	#INSERT INTO debug(txt) VALUES(CONCAT('p_unit_tier_id=', p_unit_tier_id));
	#INSERT INTO debug(txt) VALUES(CONCAT('stat_definition_txt=', stat_definition_txt));

	DELETE FROM unit_stats WHERE unit_tier_id = p_unit_tier_id;
	iterator:
	LOOP
		-- exit the loop if the list seems empty or was null;
		-- this extra caution is necessary to avoid an endless loop in the proc.
		IF CHAR_LENGTH(TRIM(stat_definition_txt)) = 0 OR stat_definition_txt IS NULL THEN
			LEAVE iterator;
		END IF;

		-- capture the next value from the list
		SET @next_stat = SUBSTRING_INDEX(stat_definition_txt,'|',1);

		-- save the length of the captured value; we will need to remove this
		-- many characters + 1 from the beginning of the string 
		-- before the next iteration
		SET @next_stat_len = CHAR_LENGTH(@next_stat);

		-- trim the value of leading and trailing spaces, in case of sloppy CSV strings
		SET @stat_scalar = SUBSTRING_INDEX(@next_stat,',',1);
		SET @stat_statValueDecimal = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_stat,',',2),',',-1);
		SET @stat_uiDisplayOverrideValue = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_stat,',',3),',',-1);
		SET @stat_unitStatId = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_stat,',',4),',',-1);
		SET @stat_unscaledDecimalValue = SUBSTRING_INDEX(SUBSTRING_INDEX(@next_stat,',',5),',',-1);

		-- insert the extracted value into the target table
		INSERT INTO unit_stats (unit_tier_id) VALUES (p_unit_tier_id);
        SET @stat_id = LAST_INSERT_ID();
		UPDATE unit_stats SET
			scalar = @stat_scalar,
            statValueDecimal = @stat_statValueDecimal,
            uiDisplayOverrideValue = @stat_uiDisplayOverrideValue,
            unitStatId = @stat_unitStatId,
            unscaledDecimalValue = @stat_unscaledDecimalValue
            WHERE id = @stat_id;
            
		-- rewrite the original string using the `INSERT()` string function,
		-- args are original string, start position, how many characters to remove, 
		-- and what to "insert" in their place (in this case, we "insert"
		-- an empty string, which removes _nextlen + 1 characters)
		SET stat_definition_txt = INSERT(stat_definition_txt,1,@next_stat_len + 1,'');
	END LOOP;
END
CREATE DEFINER=`freedbtech_guionensai`@`%` PROCEDURE `vtg`(
	IN team_name VARCHAR(255)
    )
BEGIN
	DROP VIEW IF EXISTS players_team_roster_extended;

	SELECT
		GROUP_CONCAT(DISTINCT
			CONCAT(
				'case when defId = ''',
				unit_id,
				''' then CONCAT(roster.rarity_txt, ''.'', case when roster.gear < 13 then roster.gear else concat(''R'', roster.relic_currentTier_txt) end) end AS ',
				unit_id
			)
		) INTO @sql_case
	FROM
	(
		SELECT guild_team_roster.unit_id
		FROM guild_team_roster
		JOIN guild_subteams ON guild_subteams.id = guild_team_roster.subteam_id
		JOIN guild_teams ON guild_teams.id = guild_subteams.team_id
		WHERE guild_teams.name = team_name
	) AS T;  
    
	SELECT
		GROUP_CONCAT(DISTINCT
			CONCAT(
				'GROUP_CONCAT(',
				unit_id,
				') AS ',
				unit_id
			)
		) INTO @sql_sum
	FROM
    (
		SELECT guild_team_roster.unit_id
		FROM guild_team_roster
		JOIN guild_subteams ON guild_subteams.id = guild_team_roster.subteam_id
		JOIN guild_teams ON guild_teams.id = guild_subteams.team_id
		WHERE guild_teams.name = team_name
	) AS T;
    
	SET @sql1 = CONCAT('CREATE VIEW players_team_roster_extended AS ( ',
					'SELECT players.name, roster.defId, ',
					@sql_case,
					' FROM (SELECT *, CAST(rarity AS CHAR(10)) as rarity_txt, CAST(relic_currentTier AS CHAR(10)) as relic_currentTier_txt FROM roster) AS roster',
                    ' JOIN players ON players.id = roster.player_id)');
	PREPARE stmt FROM @sql1;
	EXECUTE stmt;

	SET @sql2 = CONCAT('SELECT name, ',
					@sql_sum,
					' FROM players_team_roster_extended '
					'GROUP BY name');
	PREPARE stmt FROM @sql2;
	EXECUTE stmt;

	DEALLOCATE PREPARE stmt;

	DROP VIEW players_team_roster_extended;
END
